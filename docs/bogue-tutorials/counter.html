<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>counter (bogue-tutorials.counter)</title><link rel="stylesheet" href="../odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">bogue-tutorials</a> &#x00BB; counter</nav><header class="odoc-preamble"><h1 id="bogue-tutorial-—-a-simple-counter."><a href="#bogue-tutorial-—-a-simple-counter." class="anchor"></a>Bogue-tutorial — A simple counter.</h1><p>If you already followed the <a href="hello.html">Hello world</a> tutorial, you know how to display widgets. But what about user interaction?</p><p>In this tutorial, in the purest tradition of GUI tutorials, we will create a small app displaying the number of requested cookies; and the user can request more by clicking a button.</p></header><nav class="odoc-toc"><ul><li><a href="#displaying-the-widgets">Displaying the Widgets</a></li><li><a href="#the-logic">The logic</a></li><li><a href="#connecting-the-widgets">Connecting the widgets</a></li></ul></nav><div class="odoc-content"><h2 id="displaying-the-widgets"><a href="#displaying-the-widgets" class="anchor"></a>Displaying the Widgets</h2><p>We need a label with the word &quot;Cookies&quot;, another one displaying the number of cookies, and a button displaying the text &quot;Click for more&quot;. So we have 3 widgets. Let's place them horizontally in a layout, using the function <code>Layout.flat_of_w</code>.</p><p><div class="sidenote"><div class="collapse"></div><div class="content"> Remember that Bogue uses the &quot;housing&quot; metaphor. The function <code>flat_of_w</code> (for: &quot;flat of widgets&quot;) constructs a flat house from a list of widgets. Each widget will be installed in a room, and the house (of type <code>Layout.t</code>) is built by placing the rooms next to each other. </div></div></p><p>Ok, so let's try this.</p><pre class="language-ocaml"><code>open Bogue
module W = Widget

let () =
  let label = W.label &quot;Cookies:&quot; in
  let count = W.label &quot;0&quot; in
  let button = W.button &quot;Click for more&quot; in
  Layout.flat_of_w ~name:&quot;Counter tutorial&quot;
    ~align:Draw.Center [label; count; button]
  |&gt; Bogue.of_layout
  |&gt; Bogue.run</code></pre><p>Notice how we aliased the <code>Widget</code> module by <code>W</code>. This saves space and time, and improves readability.</p><p><div class="sidenote"><div class="collapse"></div><div class="content"> We used two optional arguments to <code>flat_of_w</code>. The <code>~name</code> will be displayed as the window name by your window manager. The <code>~align</code> parameter ensures that the 3 widgets are vertically centered (the default would by to align them by their tops. Try removing this option to see the difference.) </div></div></p><p>Here is what we get:</p><div class="figure"><img src="counter.png" srcset="counter.png 2x"></div><p>Of course, we didn't code any logic or user interaction. So this is just a dumb GUI that does nothing!</p><h2 id="the-logic"><a href="#the-logic" class="anchor"></a>The logic</h2><p>When designing a GUI, it's often useful to do the opposite: try to think about the logic, without worrying about display. Well, in our case the logic is really minimal:</p><p>We need a mutable variable for the number of cookies:</p><pre class="language-ocaml"><code>let x = ref 0</code></pre><p>and a function to increase this:</p><pre class="language-ocaml"><code>let add_cookie () = incr x</code></pre><p>That's about if for the pure logic. Of course, in a real app we would do something with <code>x</code>, for instance order the correct amount of chocolate chips.</p><h2 id="connecting-the-widgets"><a href="#connecting-the-widgets" class="anchor"></a>Connecting the widgets</h2><p>It remains to give life to our GUI inhabitants! The <code>button</code> widget should be able to talk to the <code>count</code> widget. How do we do this?</p><p>There are two aspects:</p><ol><li>Update the widgets according to our logic</li><li>React to user input</li></ol><p>In our case, the <code>count</code> widget must be updated when <code>x</code> changes. Let's write a generic function for this:</p><pre class="language-ocaml"><code>let update c n =
  W.set_text c (string_of_int n)</code></pre><p><div class="sidenote"><div class="collapse"></div><div class="content"> We have in mind that <code>update</code> will be called with arguments <code>count !x</code>. But it could be applied to any type of widget for which the function <code>W.set_text</code> makes sense. If we wanted to restrict to widgets of &quot;label&quot; type, we could have done:</p><pre class="language-ocaml"><code>let _update_label c n =
  Label.set (W.get_label c) (string_of_int n)</code></pre></div></div><p>Finally, concerning user interaction, well, this is actually easy. The function <a href="http://sanette.github.io/bogue/Bogue.Widget.html#VALbutton">Widget.button</a> has an optional parameter <code>~action</code> which executes the function <code>action : bool -&gt; unit</code> each time the button is activated by the user.</p><p>Here is our complete GUI:</p><pre class="language-ocaml"><code>let () =
  let label = W.label &quot;Cookies:&quot; in
  let count = W.label &quot;0  &quot; in
  let action _ = add_cookie (); update count !x in
  let button = W.button ~action &quot;Click for more&quot; in
  Layout.flat_of_w ~name:&quot;Counter tutorial&quot;
    ~align:Draw.Center [label; count; button]
  |&gt; Bogue.of_layout
  |&gt; Bogue.run</code></pre><div class="figure"><img src="counter.webp" srcset="counter.webp 2x"></div></div></body></html>