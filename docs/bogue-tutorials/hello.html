<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>hello (bogue-tutorials.hello)</title><link rel="stylesheet" href="../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">bogue-tutorials</a> &#x00BB; hello</nav><header class="odoc-preamble"><h1 id="bogue-tutorial-—-hello-world."><a href="#bogue-tutorial-—-hello-world." class="anchor"></a>Bogue tutorial — Hello world.</h1><style>.sidenote{font-size:smaller;background:whitesmoke;}</style><p>In this tutorial we will learn how to open a graphical window displaying a short text, like &quot;Hello world&quot;. We then take advantage of this to familiarise with basic Bogue concepts.</p></header><nav class="odoc-toc"><ul><li><a href="#hello-world">Hello world</a></li><li><a href="#more-space">More space</a></li><li><a href="#several-widgets-in-a-layout">Several widgets in a layout</a></li><li><a href="#exercise:-vertical-text">Exercise: vertical text</a></li></ul></nav><div class="odoc-content"><h2 id="hello-world"><a href="#hello-world" class="anchor"></a>Hello world</h2><p>Let's start right ahead with the &quot;minimal code&quot; mentionned in Bogue's <a href="http://sanette.github.io/bogue/Principles.html">documentation</a>:</p><pre class="language-ocaml"><code>open Bogue

let () =
  Widget.label &quot;Hello world&quot;
    |&gt; Layout.resident
    |&gt; Bogue.of_layout
    |&gt; Bogue.run</code></pre><p>We can copy this code in an OCaml toplevel and execute it; see <a href="index.html">here</a> for general instructions.</p><p>A small window should pop up like this:</p><div class="figure"><img src="hello.png" srcset="hello.png 2x"></div><p>So, how does this work? Let go through this again line by line.</p><p>First, instead of using the convenient <code>|&gt;</code> operator, let's give names to the various steps; we have the following equivalent code:</p><pre class="language-ocaml"><code>let () =
  let widget = Widget.label &quot;Hello world&quot; in
  let layout = Layout.resident widget in
  let board = Bogue.of_layout layout in
  Bogue.run board</code></pre><p>Bogue uses the &quot;housing&quot; metaphor: a GUI is a big house with inhabitants living in various rooms, (and potentially communicating with each other).</p><p>The inhabitants are the &quot;widgets&quot;. The rooms are the &quot;layouts&quot;. There are several kinds of widgets; here we create only one widget, of <code>label</code> type:</p><pre class="language-ocaml"><code>let widget = Widget.label &quot;Hello world&quot; in</code></pre><p>and we install it in a layout, as in single resident:</p><pre class="language-ocaml"><code>let layout = Layout.resident widget in</code></pre><p>Finally, this layout is the only &quot;room&quot; in our house, so we use it to create our &quot;board&quot; (which is our complete GUI):</p><pre class="language-ocaml"><code>let board = Bogue.of_layout layout in</code></pre><p>This board can be seen as our application, we run it using:</p><pre class="language-ocaml"><code>Bogue.run board</code></pre><p>Simple, isn't it?</p><h2 id="more-space"><a href="#more-space" class="anchor"></a>More space</h2><p>Well, of course there is more to it. For instance, you may find that the text label is a bit tight and needs more space around it. (In other words, the resident needs a larger room ;) )</p><p>So let's have a look at the documentation for the function <a href="https://sanette.github.io/bogue/Bogue.Layout.html#VALresident">Layout.resident</a>:</p><pre class="language-ocaml"><code>val resident :
   ?name:string -&gt; ?x:int -&gt; ?y:int -&gt; ?w:int -&gt; ?h:int -&gt;
   ?background:background -&gt;
   ?draggable:bool -&gt;
   ?canvas:Draw.canvas -&gt;
   ?keyboard_focus:bool -&gt; Widget.t -&gt; t</code></pre><p>We spot the optional parameters <code>?w</code> and <code>?h</code> which should set the desired widht and height of our layout. Let's try:</p><pre class="language-ocaml"><code>let () =
  Widget.label &quot;Hello world&quot;
    |&gt; Layout.resident ~w:300 ~h:150
    |&gt; Bogue.of_layout
    |&gt; Bogue.run</code></pre><div class="figure"><img src="hello-wide.png" srcset="hello-wide.png 2x"></div><h2 id="several-widgets-in-a-layout"><a href="#several-widgets-in-a-layout" class="anchor"></a>Several widgets in a layout</h2><p>Great, but the text feels alone... Suppose we want to display an image below our label.</p><p>Can we fit several residents in a room? Well, not really. Strictly speaking, a room can contain only one resident (widget). But, the trick is that a layout can in fact contain several rooms. Thus, an element of type <code>Layout.t</code> can either be:</p><ul><li>a true &quot;<b>room</b>&quot; (containing a single resident), or</li><li>a &quot;<b>house</b>&quot; containing several rooms.</li></ul><p><div class="sidenote"> <b>Side-note:</b> we have here the usual construction for a <em>tree</em> data structure: each node is either terminal (and called a leaf, which for us are widgets), or a vertex (for us, a layout), pointing to a list of sub-nodes.</p><p>To summarize, in Bogue, the complete GUI is simply a tree of layouts, and the leaves contain a widget.</p><p>The trunk of the tree (our main house, if you wish), will correspond to the layout associated with the window of the GUI. In Bogue we often call this special layout the &quot;top layout&quot;, or &quot;top house&quot;. (Yes, this may sound weird: our tree grows top-down...) </div></p><p>So, we want to display an image below the label. Our label is a widget:</p><pre class="language-ocaml"><code>let hello = Widget.label &quot;Hello world&quot;</code></pre><p>An image is also a widget:</p><pre class="language-ocaml"><code>let image = Widget.image &quot;bogue-icon.png&quot;</code></pre><p>Now, to put one on top of the other, we use the function <code>Layout.tower_of_w</code> (short for &quot;tower of widget&quot;) which constructs a &quot;tower&quot;:</p><pre class="language-ocaml"><code>let () =
  let hello = Widget.label &quot;Hello world&quot; in
  let image = Widget.image &quot;bogue-icon.png&quot; in
  let layout = Layout.tower_of_w [hello; image] in
  let board = Bogue.of_layout layout in
  Bogue.run board</code></pre><p>This opens a window like this:</p><div class="figure"><img src="hello-image.png" srcset="hello-image.png 2x"></div><p>What exactly does this function <code>Layout.tower_of_w</code>? It takes a list of widgets, and for each one, installs it in a room, as a resident. Then it constructs a new layout by piling up the rooms vertically.</p><p>The doc for <a href="http://sanette.github.io/bogue/Bogue.Layout.html#VALtower_of_w"><code>tower_of_w</code></a> shows interesting options. For instance, to center everything horizontally, use <code>~align:Draw.Center</code>:</p><div class="figure"><img src="hello-image-center.png" srcset="hello-image-center.png 2x"></div><h2 id="exercise:-vertical-text"><a href="#exercise:-vertical-text" class="anchor"></a>Exercise: vertical text</h2><p>What about applying what we've just learned to write &quot;Hello world&quot; <em>vertically</em>?</p><p><b>Solution:</b> Let's use <code>Layout.tower_of_w</code> to build a &quot;tower&quot; of letters.</p><pre class="language-ocaml"><code>let vertical text =
  Array.init (String.length text) (String.get text)
  |&gt; Array.to_list
  |&gt; List.map (String.make 1)
  |&gt; List.map Widget.label
  |&gt; Layout.tower_of_w

let () =
  vertical &quot;Hello world&quot;
  |&gt; Bogue.of_layout
  |&gt; Bogue.run</code></pre><div class="figure"><img src="hello-vertical.png" srcset="hello-vertical.png 2x"></div><p>Et voila !</p><p>We now know enough Bogue to play with layouts full of text and image. But, of course, a crucial part of a GUI is missing: user interaction. This will be the goal of the &quot;counter&quot; tutorial.</p></div></body></html>