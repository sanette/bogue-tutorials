<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>layouts (bogue-tutorials.layouts)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">bogue-tutorials</a> &#x00BB; layouts</nav><header class="odoc-preamble"> <!-- auto-generated file --> <h1 id="bogue-tutorial-—-layouts-:-a-tree-structure."><a href="#bogue-tutorial-—-layouts-:-a-tree-structure." class="anchor"></a>Bogue-tutorial — Layouts : a tree structure.</h1><p>In Bogue, we use Layouts to position the GUI element in our window. But there is more to this. Layouts are also a way to <em>group</em> elements together. For instance, an image can be grouped with a text describing it. In this way, if we decide to move this group elsewhere in the window, the image and the text will stay together.</p></header><nav class="odoc-toc"><ul><li><a href="#houses-and-rooms">Houses and rooms</a></li><li><a href="#a-tree-structure">A Tree structure</a></li><li><a href="#summary">Summary</a></li><li><a href="#dynamical-layouts">Dynamical layouts</a></li></ul></nav><div class="odoc-content"><h2 id="houses-and-rooms"><a href="#houses-and-rooms" class="anchor"></a>Houses and rooms</h2><p>Bogue makes use of the housing metaphor: the group is called a <em>house</em>, and it contains two <em>rooms</em>: one for the image, one for the text.</p><p>There are three basic ways of constructing a house:</p><ol><li>A <b>flat</b>: rooms are positionned next to each other, using <a href="http://sanette.github.io/bogue/Bogue.Layout.html#VALflat"><code>Layout.flat</code></a>.</li><li>A <b>tower</b>: rooms are positionned on top of each other, using <a href="http://sanette.github.io/bogue/Bogue.Layout.html#VALtower"><code>Layout.tower</code></a>.</li><li>A free arrangement, using <a href="http://sanette.github.io/bogue/Bogue.Layout.html#VALsuperpose"><code>Layout.superpose</code></a>. In this case, overlapping rooms is permitted.</li></ol><p>Let's show how it works in practice. For this tutorial, we need to have several &quot;test layouts&quot;, so let's write a generic function to construct them. Instead of an image, a plain colored box will do.</p><pre class="language-ocaml"><code>open Bogue

let make_layout ?(w=120) ?(h=90) color text =
  let text_room = Layout.resident (Widget.label text) in
  let style = Style.(of_bg (color_bg color)) in
  let image_room = Layout.resident (Widget.box ~w ~h ~style ()) in
  Layout.superpose [image_room; text_room]</code></pre><p>Notice that the house is created by using <code>superpose</code>; by default, <code>image_room</code> and <code>text_room</code> have coordinates (x,y)=(0,0), so by superposing them, the text will appear in the top left corner.</p><p><div class="sidenote"><div class="collapse"></div><div class="content"> <b>Side-note:</b> If we had used the opposite order: <code>Layout.superpose [text_room; image_room]</code>, then the text would have been hidden by the colored box (if the color was opaque). </div></div></p><p>Let's see what this gives. We may create a Bogue app with this sole &quot;house&quot;, as follows.</p><pre class="language-ocaml"><code>let () =
  make_layout Draw.(opaque (find_color &quot;lightcoral&quot;)) &quot;My first house&quot;
  |&gt; Bogue.of_layout
  |&gt; Bogue.run</code></pre><div class="figure"><img src="layout-room.png" srcset="layout-room.png 2x"></div><p>Notice that the rooms and the house in fact have the same type: they are all Layouts. Why is that? It's because we want to have the possibility to make &quot;groups of groups&quot;, or even &quot;groups of groups of groups&quot;, and so on. For instance, let's put three of the above layouts next to each other...</p><pre class="language-ocaml"><code>let r1 = make_layout Draw.(opaque (find_color &quot;lightcoral&quot;)) &quot;Layout 1&quot;
let r2 = make_layout Draw.(opaque (find_color &quot;gold&quot;)) &quot;Layout 2&quot;
let r3 = make_layout Draw.(opaque (find_color &quot;lightgreen&quot;)) &quot;Layout 3&quot;

let () =
  let house = Layout.flat ~name:&quot;A flat&quot; [r1; r2; r3] in
   Bogue.(run (of_layout house))</code></pre><div class="figure"><img src="layout-flat.png" srcset="layout-flat.png 2x"></div><p>... or on top of each other:</p><pre class="language-ocaml"><code>let () =
  let house = Layout.tower ~name:&quot;A tower&quot; [r1; r2; r3] in
  Bogue.(run (of_layout house))</code></pre><div class="figure"><img src="layout-tower.png" srcset="layout-tower.png 2x"></div><p>Now let's make a new house out of two houses: we position a flat and a tower next to each other.</p><pre class="language-ocaml"><code>let r4 = make_layout Draw.(opaque (find_color &quot;paleturquoise&quot;)) &quot;Layout 4&quot;
let r5 = make_layout Draw.(opaque (find_color &quot;plum&quot;)) &quot;Layout 5&quot;

let () =
  let flat = Layout.flat  [r1; r2; r3] in
  let tower = Layout.tower [r4; r5] in
  let house = Layout.flat [flat; tower] in
   Bogue.(run (of_layout house))</code></pre><div class="figure"><img src="layout-house.png" srcset="layout-house.png 2x"></div><h2 id="a-tree-structure"><a href="#a-tree-structure" class="anchor"></a>A Tree structure</h2><p>From what we have done, it's clear that the set of all layouts form what is called in computer science or mathematics a <em>tree</em>. The <em>trunk</em> is the largest layout, making up the whole window; in the example above, this is <code>house</code>. Then we have two <em>branches</em>, corresponding to the groups contained in this window: <code>flat</code> and <code>tower</code>. The <code>flat</code> branch splits into three new branches <code>r1</code>, <code>r2</code>, and <code>r3</code>, while the <code>tower</code> branch splits into two new branches <code>r4</code> and <code>r5</code>. Each of these branches is again split into two new branches: the text and the image. These final layouts (text and image) do not contain any other group: in Bogue's terminology, they are called <em>resident</em>; in the tree language, they are <em>leaves</em>. Leaves always contain <b>widgets</b>. (Here, the &quot;text&quot; layout contains a <code>label</code> widget, and the &quot;image&quot; layout contains a <code>box</code> widget.)</p><p>Following the tradition (for instance, think of family trees) we present the tree upside-down: the trunk is the &quot;top layout&quot;.</p><div class="figure"><img src="layout-tree.png" srcset="layout-tree.png 2x"></div><h2 id="summary"><a href="#summary" class="anchor"></a>Summary</h2><p>In Bogue, layouts are used to position the widgets in the window. The set of all layouts form a tree. A layout can either contain a widget, in which case it is a leaf, or a list of layouts, in which case it is a node. We often call such a node a <em>house</em>, and the layouts in the list are the <em>rooms</em>.</p><p>A practical consequence is that the layout structure must be constructed in a &quot;bottom-up&quot; fashion: always start from the leaves, and the trunk is the last layout we construct. The final Bogue app is constructed from this trunk, using <a href="http://sanette.github.io/bogue/Bogue.Main.html#VALof_layout"><code>Bogue.of_layout</code></a>.</p><p><div class="sidenote"><div class="collapse"></div><div class="content"> In fact, Bogue is able to handle several trees simultaneously, by opening a different window for each tree, using <a href="http://sanette.github.io/bogue/Bogue.Main.html#VALof_layout"><code>Bogue.of_layouts</code></a>. </div></div></p><h2 id="dynamical-layouts"><a href="#dynamical-layouts" class="anchor"></a>Dynamical layouts</h2><p>The tree structure we've just described is perfect for <em>static</em> layouts. When designing our app, we can sketch the GUI on a piece of paper, find out the corresponding tree, and then implement it in Bogue, starting from the leaves, and grouping them step by step, up to the trunk.</p><p>However, very often, GUI are nicer when they have <em>dynamic</em> (or &quot;responsive&quot;) components. For instance, what happens if Layout <code>r3</code>, in response to some user interaction, wants to modify Layout <code>flat</code>, to which it belongs? This is the subject of the <a href="modif_parent.html" title="modif_parent">Self-modifying layouts</a> tutorial.</p></div></body></html>
